// Copyright 2022 Matt Layher
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Command zedhookd is a receiver for ZFS events generated by the all-zedhook
// ZEDLET.
//
// For more information on ZED and ZEDLETs, see:
// https://manpages.debian.org/unstable/zfs-zed/zed.8.en.html.
package main

import (
	"encoding/json"
	"log"
	"net/http"
	"os"

	"github.com/mdlayher/zedhook/internal/zedhook"
)

func main() {
	// TODO(mdlayher): factor logic into internal/zedhook.
	mux := http.NewServeMux()
	mux.HandleFunc("/push", func(w http.ResponseWriter, r *http.Request) {
		if r.Method != http.MethodPost {
			log.Printf("%s: method not allowed: %q", r.RemoteAddr, r.Method)
			http.Error(w, "method not allowed", http.StatusMethodNotAllowed)
			return
		}

		if ct := r.Header.Get("Content-Type"); ct != "application/json; charset=utf-8" {
			log.Printf("%s: bad request content type: %q", r.RemoteAddr, ct)
			http.Error(w, "bad request content type", http.StatusBadRequest)
			return
		}

		var p zedhook.Payload
		if err := json.NewDecoder(r.Body).Decode(&p); err != nil {
			log.Printf("%s: bad request payload: %v", r.RemoteAddr, err)
			http.Error(w, "bad request payload", http.StatusBadRequest)
			return
		}

		// zedhook ZEDLET expects HTTP 204 and empty body.
		w.WriteHeader(http.StatusNoContent)

		// TODO(mdlayher): dump to stdout for now; but later store for future
		// use.
		enc := json.NewEncoder(os.Stdout)
		enc.SetIndent("", "\t")
		_ = enc.Encode(p)
	})

	// TODO(mdlayher): UNIX socket listener.
	srv := &http.Server{
		Addr:    ":9919",
		Handler: mux,
	}

	if err := srv.ListenAndServe(); err != nil {
		log.Fatalf("failed to serve: %v", err)
	}
}
